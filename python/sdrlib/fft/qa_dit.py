# Copyright (c) 2012 Ben Reynwar
# Released under MIT License (see LICENSE.txt)

"""
MyHDL Test Bench to check the vericode FFT.
"""

import os
import random
import unittest

from numpy import fft

from sdrlib.conversions import c_to_int, cs_to_int, int_to_c, int_to_cs
from sdrlib.testbench import TestBench
#from pyfft import fftstages

from sdrlib.fft.build import generate
from sdrlib import config

class DITTestBench(TestBench):
    """
    Helper class for doing testing.
    
    Args:
        nlog2: The base 2 logarithm of the FFT length.
        tf_width: Bit width of each component (real and imag) of the twiddle factor.
        x_width: Bit width of each component of the inputs and outputs.
        sendnth: Send an input on every `sendnth` clock cycle.
        data: A list of complex points to send.
    """

    def __init__(self, nlog2, width, sendnth, data):
        self.n = pow(2, nlog2)
        self.width = width
        self.nlog2 = nlog2
        TestBench.__init__(self, sendnth, data, self.width, self.width)
        outputdir = os.path.join(config.builddir, 'fft')
        self.executable = generate(self.n, self.width, outputdir)


class TestFFT(unittest.TestCase):
    
    def setUp(self):
        self.myrand = random.Random(0).random

    def test_basic(self):
        """
        Test the DUT with a random complex stream.
        """
        width = 16
        nlog2 = 4
        N = pow(2, nlog2)
        # Number of FFT to perform
        N_data_sets = 4
        # Approx many steps we'll need.
        steps_rqd = 2*N_data_sets*int(40.0 / 8 / 3 * nlog2 * N)
        # How often to send input.
        # For large FFTs this must be larger since the speed scales as NlogN.
        # Otherwise we get an overflow error.
        sendnth = 2
        # Generate some random input.
        data_sets = []
        data = []
        for i in range(0, N_data_sets):
            nd = [self.myrand()*2-1 for x in range(N)]
            data_sets.append(nd)
            data += nd
        # Create, setup and simulate the test bench.
        tb = DITTestBench(nlog2, width, sendnth, data)
        tb.simulate(steps_rqd)

        # Confirm that our data is correct.
        self.assertEqual(len(tb.output), len(data))
        rffts = [tb.output[N*i: N*(i+1)] for i in range(N_data_sets)]
        # Compare the FFT to that generated by numpy
        # The FFT from our DUT is divided by N to prevent overflow so we do the
        # same to the numpy output.
        effts = [[x/N for x in fft.fft(data_set)] for data_set in data_sets]
        i = 0
        for rfft, efft in zip(rffts, effts):
            print(i)
            i = i + 1
            print(rfft)
            print(efft)
            self.assertEqual(len(rfft), len(efft))
            for e,r in zip(efft, rfft):
                self.assertAlmostEqual(e.real, r.real, 3)
                self.assertAlmostEqual(e.imag, r.imag, 3)
                
if __name__ == '__main__':
    unittest.main()
